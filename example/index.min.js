(function(dependencies, global) {
    var cache = [];

    function require(path) {
        var module = cache[path],
            callback, exports;

        if (module === undefined) {
            callback = dependencies[path];
            exports = {};

            cache[path] = module = {
                exports: exports,
                require: require
            };

            callback.call(exports, require, exports, module, global);
        }

        return module.exports;
    }

    require.resolve = function(path) {
        return path;
    };

    if (typeof(define) === "function" && define.amd) {
        define([], function() {
            return require(0);
        });
    } else if (typeof(module) !== "undefined" && module.exports) {
        module.exports = require(0);
    } else {
        
            require(0);
        
    }
}([
function(require, exports, module, global) {

global.mat32 = require(1);


var a = mat32.create(),
    b = mat32.create(),
    c = mat32.create();

mat32.rotate(a, a, Math.PI * 0.5);
mat32.rotate(b, b, Math.PI);
mat32.mul(c, a, b);

console.log(c);


},
function(require, exports, module, global) {

var mathf = require(2),
    vec2 = require(5);


var mat32 = module.exports;


mat32.ArrayType = typeof(Float32Array) !== "undefined" ? Float32Array : mathf.ArrayType;


mat32.create = function(m11, m12, m13, m21, m22, m23) {
    var out = new mat32.ArrayType(6);

    out[0] = m11 !== undefined ? m11 : 1;
    out[2] = m12 !== undefined ? m12 : 0;
    out[1] = m21 !== undefined ? m21 : 0;
    out[3] = m22 !== undefined ? m22 : 1;
    out[4] = m13 !== undefined ? m13 : 0;
    out[5] = m23 !== undefined ? m23 : 0;

    return out;
};

mat32.copy = function(out, a) {

    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];

    return out;
};

mat32.clone = function(a) {
    var out = new mat32.ArrayType(6);

    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];

    return out;
};

mat32.set = function(out, m11, m12, m13, m21, m22, m23) {

    out[0] = m11 !== undefined ? m11 : 1;
    out[2] = m12 !== undefined ? m12 : 0;
    out[1] = m21 !== undefined ? m21 : 0;
    out[3] = m22 !== undefined ? m22 : 1;
    out[4] = m13 !== undefined ? m13 : 0;
    out[5] = m23 !== undefined ? m23 : 0;

    return out;
};

mat32.identity = function(out) {

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;

    return out;
};

mat32.zero = function(out) {

    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 0;

    return out;
};

mat32.mul = function(out, a, b) {
    var a11 = a[0],
        a12 = a[2],
        a13 = a[4],
        a21 = a[1],
        a22 = a[3],
        a23 = a[5],

        b11 = b[0],
        b12 = b[2],
        b13 = b[4],
        b21 = b[1],
        b22 = b[3],
        b23 = b[5];

    out[0] = a11 * b11 + a21 * b12;
    out[2] = a12 * b11 + a22 * b12;

    out[1] = a11 * b21 + a21 * b22;
    out[3] = a12 * b21 + a22 * b22;

    out[4] = a11 * b13 + a12 * b23 + a13;
    out[5] = a21 * b13 + a22 * b23 + a23;

    return out;
};

mat32.smul = function(out, a, s) {

    out[0] = a[0] * s;
    out[1] = a[1] * s;
    out[2] = a[2] * s;
    out[3] = a[3] * s;
    out[4] = a[4] * s;
    out[5] = a[5] * s;

    return out;
};

mat32.sdiv = function(out, a, s) {
    s = s !== 0 ? 1 / s : s;

    out[0] = a[0] * s;
    out[1] = a[1] * s;
    out[2] = a[2] * s;
    out[3] = a[3] * s;
    out[4] = a[4] * s;
    out[5] = a[5] * s;

    return out;
};

mat32.determinant = function(a) {

    return a[0] * a[3] - a[2] * a[1];
};

mat32.inverse = function(out, a) {
    var m11 = a[0],
        m12 = a[2],
        m13 = a[4],
        m21 = a[1],
        m22 = a[3],
        m23 = a[5],

        det = m11 * m22 - m12 * m21;

    if (det === 0) {
        return mat32.identity(out);
    }
    det = 1 / det;

    out[0] = m22 * det;
    out[1] = -m12 * det;
    out[2] = -m21 * det;
    out[3] = m11 * det;

    out[4] = (m21 * m23 - m22 * m13) * det;
    out[5] = -(m11 * m23 - m12 * m13) * det;

    return out;
};

mat32.transpose = function(out, a) {
    var tmp;

    if (out === a) {
        tmp = a[1];
        out[1] = a[2];
        out[2] = tmp;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }

    return out;
};

mat32.lookAt = function(out, eye, target) {
    var x = target[0] - eye[0],
        y = target[1] - eye[1],
        a = mathf.atan2(y, x) - mathf.HALF_PI,
        c = mathf.cos(a),
        s = mathf.sin(a);

    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;

    return out;
};

mat32.compose = function(out, position, scale, angle) {
    var sx = scale[0],
        sy = scale[1],
        c = mathf.cos(angle),
        s = mathf.sin(angle);

    out[0] = c * sx;
    out[1] = s * sx;
    out[2] = -s * sy;
    out[3] = c * sy;

    out[4] = position[0];
    out[5] = position[1];

    return out;
};

mat32.decompose = function(out, position, scale) {
    var m11 = out[0],
        m12 = out[1],
        sx = vec2.lengthValues(m11, m12),
        sy = vec2.lengthValues(out[2], out[3]);

    position[0] = out[4];
    position[1] = out[5];

    scale[0] = sx;
    scale[1] = sy;

    return mathf.atan2(m12, m11);
};

mat32.setRotation = function(out, angle) {
    var c = mathf.cos(angle),
        s = mathf.sin(angle);

    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;

    return out;
};

mat32.getRotation = function(out) {

    return mathf.atan2(out[1], out[0]);
};

mat32.setPosition = function(out, v) {

    out[4] = v[0];
    out[5] = v[1];

    return out;
};

mat32.getPosition = function(out, v) {

    v[0] = out[4];
    v[1] = out[5];

    return out;
};

mat32.extractPosition = function(out, a) {

    out[4] = a[4];
    out[5] = a[5];

    return out;
};

mat32.extractRotation = function(out, a) {
    var m11 = a[0],
        m12 = a[2],
        m21 = a[1],
        m22 = a[3],

        x = m11 * m11 + m21 * m21,
        y = m12 * m12 + m22 * m22,

        sx = x !== 0 ? 1 / mathf.sqrt(x) : 0,
        sy = y !== 0 ? 1 / mathf.sqrt(y) : 0;

    out[0] = m11 * sx;
    out[1] = m21 * sx;

    out[2] = m12 * sy;
    out[3] = m22 * sy;

    return out;
};

mat32.translate = function(out, a, v) {
    var x = v[0],
        y = v[1];

    out[4] = a[0] * x + a[2] * y + a[4];
    out[5] = a[1] * x + a[3] * y + a[5];

    return out;
};

mat32.rotate = function(out, a, angle) {
    var m11 = a[0],
        m12 = a[2],
        m21 = a[1],
        m22 = a[3],

        s = mathf.sin(angle),
        c = mathf.cos(angle);

    out[0] = m11 * c + m12 * s;
    out[1] = m11 * -s + m12 * c;
    out[2] = m21 * c + m22 * s;
    out[3] = m21 * -s + m22 * c;

    return out;
};

mat32.scale = function(out, a, v) {
    var x = v[0],
        y = v[1];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[4] = a[4] * x;

    out[2] = a[2] * y;
    out[3] = a[3] * y;
    out[5] = a[5] * y;

    return out;
};

mat32.orthographic = function(out, left, right, top, bottom) {
    var w = right - left,
        h = top - bottom,

        x = (right + left) / w,
        y = (top + bottom) / h;

    out[0] = 2 / w;
    out[1] = 0;
    out[2] = 0;
    out[3] = 2 / h;
    out[4] = -x;
    out[5] = -y;

    return out;
};

mat32.equal = function(a, b) {
    return !(
        a[0] !== b[0] ||
        a[1] !== b[1] ||
        a[2] !== b[2] ||
        a[3] !== b[3] ||
        a[4] !== b[4] ||
        a[5] !== b[5]
    );
};

mat32.notEqual = function(a, b) {
    return (
        a[0] !== b[0] ||
        a[1] !== b[1] ||
        a[2] !== b[2] ||
        a[3] !== b[3] ||
        a[4] !== b[4] ||
        a[5] !== b[5]
    );
};


},
function(require, exports, module, global) {

var utils = require(3);


var mathf = module.exports;


mathf.ArrayType = typeof(Float32Array) !== "undefined" ? Float32Array : Array;

mathf.PI = Math.PI;
mathf.TAU = mathf.PI * 2;
mathf.TWO_PI = mathf.TAU;
mathf.HALF_PI = mathf.PI * 0.5;
mathf.FOURTH_PI = mathf.PI * 0.25;

mathf.EPSILON = 0.000001;

mathf.TO_RADS = mathf.PI / 180;
mathf.TO_DEGS = 180 / mathf.PI;

mathf.E = Math.E;
mathf.LN2 = Math.LN2;
mathf.LN10 = Math.LN10;
mathf.LOG2E = Math.LOG2E;
mathf.LOG10E = Math.LOG10E;
mathf.SQRT1_2 = Math.SQRT1_2;
mathf.SQRT2 = Math.SQRT2;

mathf.abs = Math.abs;

mathf.acos = Math.acos;
mathf.acosh = Math.acosh || (Math.acosh = function acosh(x) {
    return Math.log(x + Math.sqrt(x * x - 1));
});
mathf.asin = Math.asin;
mathf.asinh = Math.asinh || (Math.asinh = function asinh(x) {
    if (x === -Infinity) {
        return x;
    } else {
        return Math.log(x + Math.sqrt(x * x + 1));
    }
});
mathf.atan = Math.atan;
mathf.atan2 = Math.atan2;
mathf.atanh = Math.atanh || (Math.atanh = function atanh(x) {
    return Math.log((1 + x) / (1 - x)) / 2;
});

mathf.cbrt = Math.cbrt || (Math.cbrt = function cbrt(x) {
    var y = mathf.pow(mathf.abs(x), 1 / 3);
    return x < 0 ? -y : y;
});
mathf.ceil = Math.ceil;
mathf.cos = Math.cos;
mathf.cosh = Math.cosh || (Math.cosh = function cosh(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
});

mathf.exp = Math.exp;

mathf.floor = Math.floor;
mathf.fround = Math.fround || (Math.fround = function fround(x) {
    return x;
});

mathf.log = Math.log;
mathf.log10 = Math.log10 || (Math.log10 = function log10(x) {
    return Math.log(x) / Math.LN10;
});

mathf.max = Math.max;
mathf.min = Math.min;

mathf.pow = Math.pow;

mathf.random = Math.random;
mathf.round = Math.round;

mathf.sin = Math.sin;
mathf.sinh = Math.sinh || (Math.sinh = function sinh(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
});
mathf.sqrt = Math.sqrt;

mathf.tan = Math.tan;
mathf.tanh = Math.tanh || (Math.tanh = function tanh(x) {
    if (x === Infinity) {
        return 1;
    } else if (x === -Infinity) {
        return -1;
    } else {
        return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
    }
});

mathf.equals = function(a, b, e) {

    return mathf.abs(a - b) < (e !== undefined ? e : mathf.EPSILON);
};

mathf.modulo = function(a, b) {
    var r = a % b;

    return (r * b < 0) ? r + b : r;
};

mathf.standardRadian = function(x) {

    return mathf.modulo(x, mathf.TWO_PI);
};

mathf.standardAngle = function(x) {

    return mathf.modulo(x, 360);
};

mathf.sign = function(x) {

    return x < 0 ? -1 : 1;
};

mathf.snap = function(x, y) {
    var m = x % y;

    return m < y ? x - m : x + y - m;
};

mathf.clamp = function(x, min, max) {

    return x < min ? min : x > max ? max : x;
};

mathf.clampBottom = function(x, min) {

    return x < min ? min : x;
};

mathf.clampTop = function(x, max) {

    return x > max ? max : x;
};

mathf.clamp01 = function(x) {

    return x < 0 ? 0 : x > 1 ? 1 : x;
};

mathf.truncate = function(x, n) {
    var p = mathf.pow(10, n),
        num = x * p;

    return (num < 0 ? mathf.ceil(num) : mathf.floor(num)) / p;
};

mathf.lerp = function(a, b, x) {

    return a + (b - a) * x;
};

mathf.lerpRadian = function(a, b, x) {

    return mathf.standardRadian(a + (b - a) * x);
};

mathf.lerpAngle = function(a, b, x) {

    return mathf.standardAngle(a + (b - a) * x);
};

mathf.lerpCos = function(a, b, x) {
    var ft = x * mathf.PI,
        f = (1 - mathf.cos(ft)) * 0.5;

    return a * (1 - f) + b * f;
};

mathf.lerpCubic = function(v0, v1, v2, v3, x) {
    var P, Q, R, S, Px, Qx, Rx;

    v0 || (v0 = v1);
    v3 || (v3 = v2);

    P = (v3 - v2) - (v0 - v1);
    Q = (v0 - v1) - P;
    R = v2 - v0;
    S = v1;

    Px = P * x;
    Qx = Q * x;
    Rx = R * x;

    return (Px * Px * Px) + (Qx * Qx) + Rx + S;
};

mathf.smoothStep = function(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;

    x = (x - min) / (max - min);

    return x * x * (3 - 2 * x);
};

mathf.smootherStep = function(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;

    x = (x - min) / (max - min);

    return x * x * x * (x * (x * 6 - 15) + 10);
};

mathf.pingPong = function(x, length) {
    length || (length = 1);

    return length - mathf.abs(x % (2 * length) - length);
};

mathf.degsToRads = function(x) {

    return mathf.standardRadian(x * mathf.TO_RADS);
};

mathf.radsToDegs = function(x) {

    return mathf.standardAngle(x * mathf.TO_DEGS);
};

mathf.randInt = function(min, max) {

    return mathf.round(min + (mathf.random() * (max - min)));
};

mathf.randFloat = function(min, max) {

    return min + (mathf.random() * (max - min));
};

mathf.randSign = function() {

    return mathf.random() < 0.5 ? 1 : -1;
};

mathf.shuffle = function(array) {
    var i = array.length,
        j, x;

    while (i) {
        j = (mathf.random() * i--) | 0;
        x = array[i];
        array[i] = array[j];
        array[j] = x;
    }
    return array;
};

mathf.randArg = function() {

    return arguments[(mathf.random() * arguments.length) | 0];
};

mathf.randChoice = function(array) {

    return array[(mathf.random() * array.length) | 0];
};

mathf.randChoiceObject = function(object) {
    var keys = utils.keys(object);

    return object[keys[(mathf.random() * keys.length) | 0]];
};

mathf.isPowerOfTwo = function(x) {

    return (x & -x) === x;
};

mathf.floorPowerOfTwo = function(x) {
    var i = 2,
        prev;

    while (i < x) {
        prev = i;
        i *= 2;
    }

    return prev;
};

mathf.ceilPowerOfTwo = function(x) {
    var i = 2;

    while (i < x) {
        i *= 2;
    }

    return i;
};

var n225 = 0.39269908169872414,
    n675 = 1.1780972450961724,
    n1125 = 1.9634954084936207,
    n1575 = 2.748893571891069,
    n2025 = 3.5342917352885173,
    n2475 = 4.319689898685966,
    n2925 = 5.105088062083414,
    n3375 = 5.8904862254808625,

    RIGHT = "right",
    UP_RIGHT = "up_right",
    UP = "up",
    UP_LEFT = "up_left",
    LEFT = "left",
    DOWN_LEFT = "down_left",
    DOWN = "down",
    DOWN_RIGHT = "down_right";

mathf.directionAngle = function(a) {
    a = mathf.standardRadian(a);

    if (a >= n3375 && a < n225) return RIGHT;
    if (a >= n225 && a < n675) return UP_RIGHT;
    if (a >= n675 && a < n1125) return UP;
    if (a >= n1125 && a < n1575) return UP_LEFT;
    if (a >= n1575 && a < n2025) return LEFT;
    if (a >= n2025 && a < n2475) return DOWN_LEFT;
    if (a >= n2475 && a < n2925) return DOWN;
    if (a >= n2925 && a < n3375) return DOWN_RIGHT;

    return RIGHT;
};

mathf.direction = function(x, y) {
    var a = mathf.standardRadian(mathf.atan2(y, x));

    if (a >= n3375 && a < n225) return RIGHT;
    if (a >= n225 && a < n675) return UP_RIGHT;
    if (a >= n675 && a < n1125) return UP;
    if (a >= n1125 && a < n1575) return UP_LEFT;
    if (a >= n1575 && a < n2025) return LEFT;
    if (a >= n2025 && a < n2475) return DOWN_LEFT;
    if (a >= n2475 && a < n2925) return DOWN;
    if (a >= n2925 && a < n3375) return DOWN_RIGHT;

    return RIGHT;
};


},
function(require, exports, module, global) {

var type = require(4);


var utils = module.exports,

    nativeKeys = Object.keys,
    nativeFreeze = Object.freeze,
    nativeGetPrototypeOf = Object.getPrototypeOf,
    nativeDefineProperty = Object.defineProperty,

    toString = Object.prototype.toString,
    hasOwnProp = Object.prototype.hasOwnProperty,

    wrapperDescriptor = {
        configurable: false,
        enumerable: false,
        writable: false,
        value: null
    },

    reTrim = /^[\s\xA0]+|[\s\xA0]+$/g,
    reFormat = /%([a-z%])/g;


utils.noop = function noop() {
    return undefined;
};

utils.identity = function(obj) {
    return obj;
};

utils.identityFn = function(obj) {
    return function identity() {
        return obj;
    };
};

function isObjectEmpty(object) {
    var has = hasOwnProp,
        key;

    for (key in object) {
        if (has.call(object, key)) return false;
    }

    return true;
}

utils.isEmpty = function(obj) {
    return (
        obj == null ? true : (
            type.isString(obj) || type.isArray(obj) ? obj.length === 0 : isObjectEmpty(obj)
        )
    );
};

utils.trim = function(str) {

    return type.isString(str) ? str.replace(reTrim, "") : "";
};

if (!type.isNative(nativeKeys)) {
    nativeKeys = function(obj) {
        var has = hasOwnProp,
            keys = [],
            i = 0,
            key;

        for (key in obj) {
            if (has.call(obj, key)) {
                keys[i++] = key;
            }
        }
        return keys;
    };
}

utils.keys = function(obj) {
    return nativeKeys(
        (type.isObject(obj) ? obj : Object(obj))
    );
};

if (!type.isNative(nativeFreeze)) {
    nativeFreeze = utils.identity;
}

utils.freeze = function(obj) {
    return nativeFreeze(
        (type.isObject(obj) ? obj : Object(obj))
    );
};

if (!type.isNative(nativeGetPrototypeOf)) {
    nativeGetPrototypeOf = function(obj) {
        return obj.__proto__ || (
            obj.constructor ? obj.constructor.prototype : null
        );
    };
}

utils.getPrototypeOf = function(obj) {
    return obj == null ? null : nativeGetPrototypeOf(
        (type.isObject(obj) ? obj : Object(obj))
    );
};

if (!type.isNative(nativeDefineProperty)) {
    nativeDefineProperty = function(obj, key, description) {
        if (!type.isObject(description)) {
            throw new TypeError("Property description must be an object: " + description);
        }

        if (type.isFunction(description.get)) {
            obj[key] = description.get;
        } else if (hasOwnProp.call(description, "value")) {
            obj[key] = description.value;
        }
    };
}

utils.values = function(obj) {
    var keys = utils.keys(obj),
        length = keys.length,
        i = -1,
        il = length - 1,
        result = new Array(length);

    while (i++ < il) {
        result[i] = obj[keys[i]];
    }

    return result;
};

function reverseArray(array) {
    var i = array.length,
        out = new Array(i),
        j = 0;

    while (i--) {
        out[j++] = array[i];
    }

    return out;
}

function reverseObject(object) {
    var keys = utils.keys(object),
        i = -1,
        il = keys.length - 1,
        out = {},
        key;

    while (i++ < il) {
        key = keys[i];
        out[object[key]] = key;
    }

    return out;
}

utils.reverse = function(obj) {
    return type.isArray(obj) ? reverseArray(obj) : reverseObject(type.isObject(obj) ? obj : Object(obj));
};

function arrayKeyMirror(array) {
    var i = -1,
        il = array.length - 1,
        result = {},
        key;

    while (i++ < il) {
        key = array[i] + "";
        result[key] = key;
    }

    return result;
}

function objectKeyMirror(object) {
    var keys = utils.keys(object),
        i = -1,
        il = keys.length - 1,
        result = {},
        key;

    while (i++ < il) {
        key = keys[i];
        result[key] = key;
    }

    return result;
}

utils.keyMirror = function(object) {
    return type.isArray(object) ? arrayKeyMirror(object) : objectKeyMirror(object);
};

utils.has = function(obj, key) {

    return hasOwnProp.call(obj, key);
};

function extend(a, b) {
    var keys = utils.keys(b),
        i = keys.length,
        key;

    while (i--) {
        key = keys[i];
        a[key] = b[key];
    }

    return a;
}

utils.extend = function(out) {
    var i = 0,
        length = arguments.length - 1;

    while (i++ < length) {
        extend(out, arguments[i]);
    }
    return out;
};

utils.deepExtend = function(out) {
    var i = 0,
        length = arguments.length - 1,
        seen = [],
        copied = [];

    while (i++ < length) {
        extend(out, deepCopy(arguments[i], seen, copied));
        seen.length = 0;
        copied.length = 0;
    }
    return out;
};

function merge(a, b) {
    var keys = utils.keys(b),
        i = keys.length,
        key, value;

    while (i--) {
        key = keys[i];
        if ((value = b[key]) != null) a[key] = value;
    }

    return a;
}

utils.merge = function(out) {
    var i = 0,
        length = arguments.length - 1;

    while (i++ < length) {
        merge(out, arguments[i]);
    }
    return out;
};

utils.deepMerge = function(out) {
    var i = 0,
        length = arguments.length - 1,
        seen = [],
        copied = [];

    while (i++ < length) {
        merge(out, deepCopy(arguments[i], seen, copied));
        seen.length = 0;
        copied.length = 0;
    }
    return out;
};

function mixin(a, b) {
    var keys = utils.keys(b),
        i = keys.length,
        key, value;

    while (i--) {
        key = keys[i];
        if (a[key] == null && (value = b[key]) != null) a[key] = value;
    }

    return a;
}

utils.mixin = function(out) {
    var i = 0,
        length = arguments.length - 1;

    while (i++ < length) {
        mixin(out, arguments[i]);
    }
    return out;
};

utils.deepMixin = function(out) {
    var i = 0,
        length = arguments.length - 1,
        seen = [],
        copied = [];

    while (i++ < length) {
        mixin(out, deepCopy(arguments[i], seen, copied));
        seen.length = 0;
        copied.length = 0;
    }
    return out;
};

utils.copy = function(obj) {
    if (!type.isObject(obj)) return obj;
    return type.isArray(obj) ? slice(obj) : extend({}, obj);
};

function deepCopy(obj, seen, copied) {
    var has = hasOwnProp,
        index, out, i, il, length, key;

    if (!type.isObject(obj) || type.isFunction(obj)) {
        return obj;
    }

    if ((index = utils.indexOf(seen, obj)) !== -1) {
        return copied[index];
    }

    seen[seen.length] = obj;

    if (type.isArray(obj)) {
        length = obj.length;
        i = -1;
        il = length - 1;

        out = new Array(length);
        copied[copied.length] = out;

        while (i++ < il) {
            out[i] = deepCopy(obj[i], seen, copied);
        }

        return out;
    } else if (type.isDate(obj)) {
        out = new Date(obj);
    } else {
        out = {};
    }

    copied[copied.length] = out;

    for (key in obj) {
        if (has.call(obj, key)) {
            out[key] = deepCopy(obj[key], seen, copied);
        }
    }

    return out;
}

utils.deepCopy = function(obj) {

    return deepCopy(obj, [], []);
};

utils.indexOf = function(array, value, fromIndex) {
    var i = (fromIndex || 0) - 1,
        il = array.length - 1;

    while (i++ < il) {
        if (value === array[i]) return i;
    }

    return -1;
};

utils.remove = function(array, value, fromIndex) {
    var index = utils.indexOf(array, value, fromIndex);

    if (index !== -1) {
        array.splice(index, 1);
        return index;
    }

    return -1;
};

function unique(array) {
    var indexOf = utils.indexOf,
        i = -1,
        il = array.length - 1,
        result = [],
        seen = [];

    while (i++ < il) {
        value = array[i];

        if (indexOf(seen, value) === -1) {
            result[result.length] = value;
            seen[seen.length] = value;
        }
    }

    return result;
}

function flattenArray(array, depth, result) {
    var isArray = type.isArray,
        i = -1,
        il = array.length - 1,
        value;

    depth = depth != null ? depth : -1;
    result = result || [];

    while (i++ < il) {
        value = array[i];

        if ((depth === -1 || depth > 0) && isArray(value)) {
            flattenArray(value, depth - 1, result);
        } else {
            result[result.length] = value;
        }
    }

    return result;
}

utils.unique = function() {
    return unique(flattenArray(slice(arguments), 1));
};

function difference(obj, rest) {
    var i = -1,
        il = obj.length - 1,
        restLength = rest.length,
        result = [],
        j, value, pass;

    while (i++ < il) {
        value = obj[i];
        pass = true;

        j = restLength;

        while (j--) {
            if (value === rest[j]) {
                pass = false;
                break;
            }
        }

        if (pass) {
            result[result.length] = value;
        }
    }

    return result;
}

utils.difference = function(obj) {
    return difference(obj, flattenArray(slice(arguments, 1)));
};

utils.create = Object.create || (function() {
    function F() {}
    return function create(obj) {
        F.prototype = obj;
        return new F();
    };
}());

function Wrapper() {
    this.thisArg = null;
    this.args = null;
    this.argsRight = null;
}

function slice(array, offset) {
    var length, i, il, result, j;

    offset = offset || 0;

    length = array.length;
    i = offset - 1;
    il = length - 1;
    result = new Array(length - offset);
    j = 0;

    while (i++ < il) {
        result[j++] = array[i];
    }

    return result;
}

function concat(a, b) {
    var aLength = a.length,
        bLength = b.length,
        i = aLength,
        result = new Array(aLength + bLength);

    while (i--) {
        result[i] = a[i];
    }
    i = bLength;
    while (i--) {
        result[aLength + i] = b[i];
    }

    return result;
}

function mergeArrays(a, b) {
    var aLength = a.length,
        bLength = b.length,
        i = bLength;

    a.length += bLength;

    while (i--) {
        a[aLength + i] = b[i];
    }
    return a;
}

function callWrapperFunction(func, args, argsLength, thisArg) {
    return (
        thisArg != null ? (
            argsLength === 0 ? func.call(thisArg) :
            argsLength === 1 ? func.call(thisArg, args[0]) :
            argsLength === 2 ? func.call(thisArg, args[0], args[1]) :
            argsLength === 3 ? func.call(thisArg, args[0], args[1], args[2]) :
            argsLength === 4 ? func.call(thisArg, args[0], args[1], args[2], args[3]) :
            argsLength === 5 ? func.call(thisArg, args[0], args[1], args[2], args[3], args[4]) :
            func.apply(thisArg, args)
        ) : (
            argsLength === 0 ? func() :
            argsLength === 1 ? func(args[0]) :
            argsLength === 2 ? func(args[0], args[1]) :
            argsLength === 3 ? func(args[0], args[1], args[2]) :
            argsLength === 4 ? func(args[0], args[1], args[2], args[3]) :
            argsLength === 5 ? func(args[0], args[1], args[2], args[3], args[4]) :
            func.apply(null, args)
        )
    );
}

function createWrapper(func) {
    var wrapper;

    if (hasOwnProp.call(func, "__wrapper__")) {
        wrapper = func;
    } else {
        wrapper = function wrapper() {
            var __wrapper__ = wrapper.__wrapper__,
                wrapperArgs = __wrapper__.args,
                wrapperArgsRight = __wrapper__.argsRight,
                args = slice(arguments);

            if (wrapperArgs) {
                args = concat(wrapperArgs, args);
            }
            if (wrapperArgsRight) {
                args = mergeArrays(args, wrapperArgsRight);
            }

            return callWrapperFunction(func, args, args.length, __wrapper__.thisArg);
        };

        wrapperDescriptor.value = new Wrapper();
        nativeDefineProperty(wrapper, "__wrapper__", wrapperDescriptor);
        wrapperDescriptor.value = null;
    }

    return wrapper;
}

utils.bind = function(func, thisArg) {
    var wrapper = createWrapper(func),
        __wrapper__ = wrapper.__wrapper__;

    __wrapper__.thisArg = thisArg;

    if (arguments.length > 2) {
        if (!__wrapper__.args) {
            __wrapper__.args = slice(arguments, 2);
        } else {
            __wrapper__.args = mergeArrays(__wrapper__.args, slice(arguments, 2));
        }
    }

    return wrapper;
};

utils.bindThis = function(func, thisArg) {
    var wrapper = createWrapper(func);

    wrapper.__wrapper__.thisArg = thisArg;

    return wrapper;
};

utils.curry = function(func) {
    var wrapper = createWrapper(func),
        __wrapper__ = wrapper.__wrapper__;

    if (arguments.length > 1) {
        if (!__wrapper__.args) {
            __wrapper__.args = slice(arguments, 1);
        } else {
            __wrapper__.args = mergeArrays(__wrapper__.args, slice(arguments, 1));
        }
    }

    return wrapper;
};

utils.curryRight = function(func) {
    var wrapper = createWrapper(func),
        __wrapper__ = wrapper.__wrapper__;

    if (arguments.length > 1) {
        if (!__wrapper__.argsRight) {
            __wrapper__.argsRight = slice(arguments, 1);
        } else {
            __wrapper__.argsRight = mergeArrays(__wrapper__.argsRight, slice(arguments, 1));
        }
    }

    return wrapper;
};

utils.inherits = function(child, parent) {

    child.prototype = utils.create(parent.prototype);
    child.prototype.constructor = child;
    child._super = parent.prototype;

    return child;
};

utils.assert = function(condition) {
    var error;

    if (!condition) {
        error = new Error(
            "Assert Violation: " + format.apply(null, slice(arguments, 1))
        );
        error.framesToPop = 1;

        throw error;
    }
};

function format(str) {
    var i = 1,
        args = arguments,
        length = args.length;

    return (type.isString(str) ? str + "" : "").replace(reFormat, function(match, s) {
        var value, formatter;

        if (match === "%%") return "%";
        if (i >= length) return "";

        formatter = format[s];
        value = args[i++];

        return value != null && type.isFunction(formatter) ? formatter(value) : "";
    });
}

format.s = function(obj) {
    return String(obj);
};

format.d = function(obj) {
    return Number(obj);
};

format.j = function(obj) {
    try {
        return JSON.stringify(obj);
    } catch (e) {
        return "[Circular]";
    }
};

function inspectObject(obj, inspected, depth, maxDepth) {
    var out, i, il, keys, key;

    if (utils.indexOf(inspected, obj) !== -1) {
        return toString.call(obj);
    }

    inspected[inspected.length] = obj;

    if (type.isFunction(obj) || depth >= maxDepth) {
        return toString.call(obj);
    }

    if (type.isArrayLike(obj) && obj !== global) {
        depth++;
        out = [];

        i = -1;
        il = obj.length - 1;
        while (i++ < il) {
            out[i] = inspect(obj[i], inspected, depth, maxDepth);
        }

        return out;
    } else if (type.isObject(obj)) {
        depth++;
        out = {};
        keys = utils.keys(obj);

        i = -1;
        il = keys.length - 1;
        while (i++ < il) {
            key = keys[i];
            out[key] = inspect(obj[key], inspected, depth, maxDepth);
        }

        return out;
    }

    return type.isFunction(obj.toString) ? obj.toString() : obj + "";
}

function inspectPrimitive(obj) {
    return type.isNumber(obj) ? Number(obj) : String(obj);
}

function inspect(obj, inspected, depth, maxDepth) {
    return type.isPrimitive(obj) ? inspectPrimitive(obj) : inspectObject(obj, inspected, depth, maxDepth);
}

format.o = function(obj) {
    try {
        return JSON.stringify(inspect(obj, [], 0, 5), null, 2);
    } catch (e) {
        return "[Circular]";
    }
};

utils.format = format;

utils.formatArgs = function(str, args) {
    var i = 0,
        length = args ? args.length : 0;

    return (type.isString(str) ? str + "" : "").replace(reFormat, function(match, s) {
        var value, formatter;

        if (match === "%%") return "%";
        if (i >= length) return "";

        formatter = format[s];
        value = args[i++];

        return value != null && type.isFunction(formatter) ? formatter(value) : "";
    });
};


},
function(require, exports, module, global) {

var type = module.exports,

    toString = Object.prototype.toString,
    fnToString = Function.prototype.toString,

    reHostCtor = /^\[object .+?Constructor\]$/,

    reNative = RegExp("^" +
        fnToString.call(toString)
        .replace(/[.*+?^${}()|[\]\/\\]/g, "\\$&")
        .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ),

    isHostObject;


type.isObject = function(obj) {
    var typeStr;

    return obj != null && ((typeStr = typeof(obj)) === "object" || typeStr === "function");
};

type.isHash = function(obj) {

    return toString.call(obj) === "[object Object]";
};

type.isArrayLike = function(obj) {

    return obj != null && !type.isWindow(obj) && (obj.length === +obj.length);
};

type.isArray = Array.isArray || function isArray(obj) {

    return toString.call(obj) === "[object Array]";
};

type.isArguments = function(obj) {

    return toString.call(obj) === "[object Arguments]";
};

if (typeof(/./) !== "function") {
    type.isFunction = function(obj) {

        return typeof(obj) === "function";
    };
} else {
    type.isFunction = function(obj) {

        return toString.call(obj) === "[object Function]";
    };
}

type.isString = function(obj) {

    return typeof(obj) === "string";
};

type.isNumber = function(obj) {

    return typeof(obj) === "number";
};

type.isFinite = Number.isFinite || function isFinite(obj) {
    return !(
        typeof(obj) !== "number" ||
        (obj !== obj || obj === Infinity || obj === -Infinity) ||
        false
    );
};

type.isNaN = Number.isNaN || function(obj) {

    return type.isNumber(obj) && (obj !== obj);
};

type.isDecimal = function(obj) {

    return type.isNumber(obj) && obj % 1 !== 0;
};

type.isFloat = type.isDecimal;

type.isInteger = function(obj) {

    return type.isNumber(obj) && obj % 1 === 0;
};

type.isInt = type.isInteger;

type.isDate = function(obj) {

    return toString.call(obj) === "[object Date]";
};

type.isRegExp = function(obj) {

    return toString.call(obj) === "[object RegExp]";
};

type.isBoolean = function(obj) {

    return obj === true || obj === false;
};

type.isNull = function(obj) {

    return obj === null;
};

type.isUndefined = function(obj) {

    return obj === undefined;
};

type.isUndefinedOrNull = function(obj) {

    return obj == null;
};

type.isDefined = function(obj) {

    return obj != null;
};

type.isPrimitive = function(obj) {
    var typeStr;
    return obj == null || ((typeStr = typeof(obj)) !== "object" && typeStr !== "function");
};

type.isError = function(obj) {

    return toString.call(obj) === "[object Error]";
};

isHostObject = (function() {
    try {
        String({
            "toString": 0
        } + "");
    } catch (e) {
        return function isHostObject() {
            return false;
        };
    }

    return function isHostObject(value) {
        return !type.isFunction(value.toString) && typeof(value + "") === "string";
    };
}());

type.isNative = function(obj) {
    return obj != null && (
        type.isFunction(obj) ?
        reNative.test(fnToString.call(obj)) : (
            typeof(obj) === "object" && (
                (isHostObject(obj) ? reNative : reHostCtor).test(obj) || false
            )
        )
    );
};

type.isNode = function(obj) {
    return obj != null && (
        type.isFunction(Node) ? obj instanceof Node : (
            typeof(obj) === "object" &&
            typeof(obj.nodeType) === "number" &&
            typeof(obj.nodeName) === "string"
        )
    );
};

type.isTextNode = function(obj) {

    return type.isNode(obj) && obj.nodeType === 3;
};

type.isTextInputElement = (function() {
    var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
    };

    return function isTextInputElement(obj) {
        return obj != null && (
            (obj.nodeName === "INPUT" && supportedInputTypes[obj.type]) ||
            obj.nodeName === "TEXTAREA"
        );
    };
}());

type.isElement = function(obj) {
    return obj != null && (
        type.isFunction(HTMLElement) ? obj instanceof HTMLElement : (
            typeof(obj) === "object" &&
            obj.nodeType === 1 &&
            typeof(obj.nodeName) === "string"
        )
    );
};

type.isEventTarget = function(obj) {
    return obj != null && (
        type.isFunction(EventTarget) ? obj instanceof EventTarget : (
            type.isFunction(obj.addEventListener) ||
            type.isFunction(obj.attachEvent)
        )
    );
};

type.isDocument = function(obj) {

    return type.isNode(obj) && obj.nodeType === 9;
};

type.isWindow = function(obj) {

    return obj != null && obj.window === obj;
};

type.isGlobal = function(obj) {

    return obj === global;
};


},
function(require, exports, module, global) {

var mathf = require(2);


var vec2 = module.exports;


vec2.create = function(x, y) {

    return vec2.set(new mathf.ArrayType(2), x, y);
};

vec2.copy = function(a, b) {
    a[0] = b[0];
    a[1] = b[1];

    return a;
};

vec2.set = function(a, x, y) {
    a[0] = x !== undefined ? x : 0;
    a[1] = y !== undefined ? y : 0;

    return a;
};

vec2.add = function(a, b, out) {
    out = out || a;

    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];

    return a;
};

vec2.sub = function(a, b, out) {
    out = out || a;

    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];

    return out;
};

vec2.mul = function(a, b, out) {
    out = out || a;

    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];

    return out;
};

vec2.div = function(a, b, out) {
    var bx = b[0],
        by = b[1];

    out = out || a;

    out[0] = a[0] * (bx !== 0 ? 1 / bx : bx);
    out[1] = a[1] * (by !== 0 ? 1 / by : by);

    return out;
};

vec2.sadd = function(a, s, out) {
    out = out || a;

    out[0] = a[0] + s;
    out[1] = a[1] + s;

    return a;
};

vec2.ssub = function(a, s, out) {
    out = out || a;

    out[0] = a[0] - s;
    out[1] = a[1] - s;

    return out;
};

vec2.smul = function(a, s, out) {
    out = out || a;

    out[0] = a[0] * s;
    out[1] = a[1] * s;

    return out;
};

vec2.sdiv = function(a, s, out) {
    s = s !== 0 ? 1 / s : s;

    out = out || a;

    out[0] = a[0] * s;
    out[1] = a[1] * s;

    return out;
};

vec2.dot = function(a, b) {

    return a[0] * b[0] + a[1] * b[1];
};

vec2.cross = function(a, b) {

    return a[0] * b[1] - a[1] * b[0];
};

vec2.lengthSq = function(a) {

    return vec2.dot(a, a);
};

vec2.length = function(a) {
    var lsq = vec2.lengthSq(a);

    return lsq !== 0 ? mathf.sqrt(lsq) : lsq;
};

vec2.invLength = function(a) {
    var lsq = vec2.lengthSq(a);

    return lsq !== 0 ? 1 / mathf.sqrt(lsq) : lsq;
};

vec2.setLength = function(a, length) {

    return vec2.smul(a, vec2.invLength(a) * length);
};

vec2.normalize = function(a) {

    return vec2.sdiv(a, vec2.length(a));
};

vec2.inverse = function(a, out) {
    out = out || a;

    out[0] = a[0] * -1;
    out[1] = a[1] * -1;

    return out;
};

vec2.lerp = function(a, b, x, out) {
    var lerp = mathf.lerp;

    out = out || a;

    out[0] = lerp(a[0], b[0], x);
    out[1] = lerp(a[1], b[1], x);

    return out;
};

vec2.perp = function(a, out) {
    out = out || a;

    out[0] = -a[1];
    out[1] = a[0];

    return out;
};

vec2.perpL = function(a, out) {
    out = out || a;

    out[0] = a[1];
    out[1] = -a[0];

    return out;
};

vec2.min = function(a, b, out) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1];

    out = out || a;

    out[0] = bx < ax ? bx : ax;
    out[1] = by < ay ? by : ay;

    return out;
};

vec2.max = function(a, b, out) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1];

    out = out || a;

    out[0] = bx > ax ? bx : ax;
    out[1] = by > ay ? by : ay;

    return out;
};

vec2.clamp = function(a, min, max, out) {
    var x = a[0],
        y = a[1],
        minx = min[0],
        miny = min[1],
        maxx = max[0],
        maxy = max[1];

    out = out || a;

    out[0] = x < minx ? minx : x > maxx ? maxx : x;
    out[1] = y < miny ? miny : y > maxy ? maxy : y;

    return out;
};

vec2.transformAngle = function(a, angle, out) {
    var x = a[0],
        y = a[1],
        c = mathf.cos(angle),
        s = mathf.sin(angle);

    out = out || a;

    out[0] = x * c - y * s;
    out[1] = x * s + y * c;

    return out;
};

vec2.transformMat2 = function(a, m, out) {
    var x = a[0],
        y = a[1];

    out = out || a;

    out[0] = x * m[0] + y * m[2];
    out[1] = x * m[1] + y * m[3];

    return out;
};

vec2.untransformMat2 = function(a, m, out) {
    var x = a[0],
        y = a[1];

    out = out || a;

    out[0] = x * m[0] + y * m[1];
    out[1] = x * m[2] + y * m[3];

    return out;
};

vec2.transformMat32 = function(a, m, out) {
    var x = a[0],
        y = a[1];

    out = out || a;

    out[0] = x * m[0] + y * m[2] + m[4];
    out[1] = x * m[1] + y * m[3] + m[5];

    return out;
};

vec2.untransformMat32 = function(a, m, out) {
    var x = a[0] - m[4],
        y = a[1] - m[5];

    out = out || a;

    out[0] = x * m[0] + y * m[1];
    out[1] = x * m[2] + y * m[3];

    return out;
};

vec2.transformMat3 = function(a, m, out) {
    var x = a[0],
        y = a[1];

    out = out || a;

    out[0] = x * m[0] + y * m[3] + m[6];
    out[1] = x * m[1] + y * m[4] + m[7];

    return out;
};

vec2.transformMat4 = function(a, m, out) {
    var x = a[0],
        y = a[1];

    out = out || a;

    out[0] = x * m[0] + y * m[4] + m[12];
    out[1] = x * m[1] + y * m[5] + m[13];

    return out;
};

vec2.transformProjection = function(a, m, out) {
    var x = a[0],
        y = a[1],
        d = m[3] * x + m[7] * y + m[11] + m[15];

    d = d !== 0 ? 1 / d : d;
    out = out || a;

    out[0] = (x * m[0] + y * m[4] + m[12]) * d;
    out[1] = (x * m[1] + y * m[5] + m[13]) * d;

    return out;
};

vec2.positionFromMat32 = function(a, m) {
    a[0] = m[4];
    a[1] = m[5];

    return a;
};

vec2.positionFromMat4 = function(a, m) {
    a[0] = m[12];
    a[1] = m[13];

    return a;
};

vec2.scaleFromMat2 = function(a, m) {
    a[0] = vec2.length(vec2.set(a, m[0], m[2]));
    a[1] = vec2.length(vec2.set(a, m[1], m[3]));

    return a;
};

vec2.scaleFromMat32 = vec2.scaleFromMat2;

vec2.equal = function(a, b) {
    return !(
        a[0] !== b[0] ||
        a[1] !== b[1]
    );
};

vec2.notEqual = function(a, b) {
    return (
        a[0] !== b[0] ||
        a[1] !== b[1]
    );
};


}], (new Function("return this;"))()));
